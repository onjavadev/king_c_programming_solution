# 01 Введение в С

> Когда кто-то скажет: "Я хочу язык программирования, в котором мне нужно только сказать, что я хочу сделать", - дайте ему леденец.
> 

![Untitled](e497702bed94489fb87433e88c695efa/belllabs.gif)

[Bell Labs - The Company that Invented the Future](https://youtu.be/eksTJOmlxbU)

[UNIX. Творение ученых в недрах лаборатории](https://youtu.be/VFyYWzhdL2c)

Что такое *C*? Простой ответ - широко используемый язык программирования, разработанный в начале 1970-х годов в *Bell Laboratories*, - мало передает особый колорит языка *С*. Прежде чем погрузиться в детали языка, давайте посмотрим, откуда взялся *С*, для чего он был разработан и как он изменился за эти годы (раздел 1.1). Мы также обсудим сильные и слабые стороны *С* и расскажем, как получить максимальную отдачу от языка (раздел 1.2).

[Лаборатории Белла - Википедия](https://ru.wikipedia.org/wiki/%D0%9B%D0%B0%D0%B1%D0%BE%D1%80%D0%B0%D1%82%D0%BE%D1%80%D0%B8%D0%B8_%D0%91%D0%B5%D0%BB%D0%BB%D0%B0)

# 1.1. История С

Давайте вкратце рассмотрим историю языка *C*, начиная с его происхождения, его становления как стандартизированного языка и заканчивая его влиянием на языки последних поколений.

## Происхождение

*С* является побочным продуктом операционной системы *UNIX*, которая была разработана в *Bell Laboratories* Кеном Томпсоном, Деннисом Ричи и другими. Томпсон в одиночку написал первоначальную версию *UNIX*, которая работала на компьютере *DEC PDP-7*, раннем миникомпьютере с оперативной памятью всего *8K* слов (это был 1969 год, в конце концов!).

[PDP-7 - Википедия](https://ru.wikipedia.org/wiki/PDP-7)

[Томпсон, Кен - Википедия](https://ru.wikipedia.org/wiki/%D0%A2%D0%BE%D0%BC%D0%BF%D1%81%D0%BE%D0%BD,_%D0%9A%D0%B5%D0%BD)

[Ритчи, Деннис - Википедия](https://ru.wikipedia.org/wiki/Ритчи,_Деннис)

Как и другие операционные системы того времени, *UNIX* была написана на языке ассемблера. Программы, написанные на языке ассемблера, обычно трудно отлаживать и трудно улучшать; *UNIX* не была исключением. Томпсон решил, что для дальнейшего развития *UNIX* необходим язык более высокого уровня, поэтому он разработал небольшой язык под названием *B*. Томпсон взял за основу *B* язык *BCPL*, язык системного программирования, разработанный в середине 1960-х годов. *BCPL*, в свою очередь, ведет свою родословную от *Algol 60*, одного из самых ранних (и наиболее влиятельных) языков программирования.

[](https://ru.wikipedia.org/wiki/%D0%A0%D0%B8%D1%82%D1%87%D0%B8,_%D0%94%D0%B5%D0%BD%D0%BD%D0%B8%D1%81)

Вскоре Ричи присоединился к проекту *UNIX* и начал программировать на *B*. В 1970 году *Bell Laboratories* приобрела для проекта *UNIX* компьютер *PDP-11*. Как только *B* был запущен на *PDP-11*, Томпсон переписал часть *UNIX* на *B*. К 1971 году стало очевидно, что *B* не очень хорошо подходит для *PDP-11*, поэтому Ритчи начал разрабатывать расширенную версию *B*. Сначала он назвал свой язык *NB* ("Новый B'"), а затем, когда он стал больше отличаться от *B*, он изменил название на *C*. К 1973 году язык был достаточно стабилен, чтобы *UNIX* можно было переписать на *C.* Переход на *C* обеспечил важное преимущество: *переносимость*. Написав компиляторы языка *C* для других компьютеров в *Bell Laboratories*, команда могла запустить *UNIX* и на этих машинах.

[PDP-11 - Википедия](https://ru.wikipedia.org/wiki/PDP-11)

## Стандартизация

*С* продолжал развиваться в течение 1970-х годов, особенно в 1977-1979 годах. Именно в этот период появилась первая книга по языку *С*. Книга "*Язык программирования С*", написанная Брайаном Керниганом и Деннисом Ричи и опубликованная в 1978 году, быстро стала библией программистов на *С*. В отсутствие официального стандарта для языка *C* эта книга, известная как "*K&R*" или "*Белая книга*" для любителей, стала стандартом де-факто.

В 1970-х годах программистов на языке *С* было относительно немного, и большинство из них были пользователями *UNIX*. Однако к 1980-м годам *С* вышел за пределы узкого круга *UNIX*. Компиляторы языка *С* стали доступны на различных машинах, работающих под управлением различных операционных систем. В частности, *C* начал утверждаться на быстро развивающейся платформе *IBM PC*.

С ростом популярности языка *С* возникли проблемы. Программисты, писавшие новые компиляторы языка *С*, полагались на *K&R* как на справочник. К сожалению, *K&R* нечетко описывал некоторые особенности языка, поэтому компиляторы часто трактовали эти особенности по-разному. Кроме того, в *K&R* не было четкого разграничения между тем, какие функции принадлежат языку *C*, а какие являются частью *UNIX*. Еще хуже то, что после публикации *K&R* язык *C* продолжал меняться: добавлялись новые возможности и удалялись некоторые старые. Вскоре стала очевидной необходимость в тщательном, точном и актуальном описании языка. Без такого стандарта возникли бы многочисленные диалекты, что поставило бы под угрозу переносимость программ на языке *C* - одно из главных достоинств языка.

Разработка американского стандарта для языка *C* началась в 1983 году под эгидой Американского национального института стандартов (*ANSI*). После многочисленных пересмотров стандарт был завершен в 1988 году и официально утвержден в декабре 1989 года как стандарт *ANSI X3.159-1989*. В 1990 году стандарт был утвержден Международной организацией по стандартизации (*ISO*) как международный стандарт *ISO/IEC 9899:1990*. Эта версия языка обычно называется *C89* или *C90*, чтобы отличить *С* от оригинальной версии *C*, часто называемой *K&R C*. В приложении *C* приведены основные различия между *C89* и *K&R C*.

В 1995 году язык претерпел некоторые изменения (описанные в документе, известном как *Поправка 1*). Более значительные изменения произошли с публикацией нового стандарта *ISO/IEC 9899:1999* в 1999 году. Язык, описанный в этом стандарте, широко известен как *C99*. Термины “*ANSI C*”,             “*ANSI/ISO C*” и “*ISO C*”, которые когда-то использовались для описания *C89* - теперь неоднозначны, благодаря существованию двух стандартов.

Поскольку *C99* еще не стал универсальным, а также из-за необходимости поддерживать миллионы (если не миллиарды) строк кода, написанного на старых версиях *C*, я буду использовать специальный значок (показан на левом поле), чтобы отметить обсуждение возможностей, которые были добавлены в *C99*. Компилятор, который не распознает эти возможности, не является "*C99-совместимым*". Если верить истории, пройдет еще несколько лет, прежде чем все компиляторы языка *С* станут совместимыми с *C99*, если вообще станут. В *Приложении B* перечислены основные различия между *C99* и *C89*.

## Языки на основе С

Язык *C* оказал огромное влияние на современные языки программирования, многие из которых в значительной степени заимствуют его. Из множества языков, основанных на *С*, особенно выделяются несколько:

- *C++* включает все возможности языка *C*, но добавляет классы и другие возможности для объектно-ориентированного программирования.
- *Java* основан на *C++* и поэтому унаследовал многие возможности *C*.
- *C#* - более современный язык, производный от *C++* и *Java*.
- *Perl* изначально был довольно простым скриптовым языком; со временем он вырос и унаследовал многие возможности языка *C*.

Учитывая популярность этих новых языков, логично спросить, стоит ли изучать *С*. Я думаю, что стоит, по нескольким причинам. Во-первых, изучение *C* может дать вам большее представление о возможностях *C++*, *Java*, *C#*, *Perl* и других языков, основанных на *C*. Программисты, которые сначала изучают один из этих языков, часто не могут освоить основные функции, унаследованные от *C*.
Во-вторых, в мире существует множество старых программ на языке *C*; возможно, вам придется читать и разбираться в этом коде. 

В-третьих, *С* по-прежнему широко используется для разработки нового программного обеспечения, особенно в ситуациях, когда память или вычислительная мощность ограничены или когда желательна простота *С*.

Если вы еще не использовали ни один из новых языков на базе языка *С*, вы обнаружите, что эта книга является отличной подготовкой к изучению этих языков. В ней делается акцент на абстракции данных, сокрытии информации и других принципах, которые играют большую роль ни объектно-ориентированном программировании. *C++* включает в себя все возможности языка *C*, поэтому вы сможете использовать все, что узнаете из этой книги, если в дальнейшем будете изучать *C++*. Многие из особенностей языка *C* можно найти и в других языках, основанных на *C*.

# 1.2. Сильные и слабые стороны С

Как и любой другой язык программирования, C имеет сильные и слабые стороны. Оба они обусловлены первоначальным использованием языка (написание операционных систем и другого системного программного обеспечения) и лежащей в его основе философией:

- ***С* - это язык низкого уровня**. Чтобы служить подходящим языком для системного программирования, *C* обеспечивает доступ к понятиям машинного уровня (например, байтам и адресам), которые другие языки программирования пытаются скрыть. *С* также предоставляет операции, которые близко соответствуют встроенным инструкциям компьютера, чтобы программы могли быть быстрыми. Поскольку прикладные программы полагаются на *С* для ввода/вывода, управления хранением и множества других услуг, операционная система не может позволить себе быть медленной.
- ***С* - это небольшой язык**. *С* предоставляет более ограниченный набор функций, чем многие языки. (Справочное руководство во втором издании K&R охватывает весь язык на 49 страницах). Чтобы сохранить небольшое количество функций, язык *C* в значительной степени опирается на "библиотеку" стандартных функций. Функция похожа на то, что в других языках программирования называется "процедура", "подпрограмма" или "метод".
- **Язык *C* - это разрешительный язык**. *С* предполагает, что вы знаете, что делаете, поэтому он позволяет вам более широкую свободу действий, чем многие языки. Более того, *С* не требует подробной проверки ошибок, характерной для других языков.

## Сильные стороны

Сильные стороны языка C помогают объяснить, почему он стал таким популярным:

- **Эффективность**. Эффективность была одним из преимуществ языка *С* с самого начала. Поскольку язык *С* был предназначен для приложений, где традиционно использовался язык ассемблера, было очень важно, чтобы программы на языке *С* могли выполняться быстро и занимать ограниченный объем памяти.
- **Переносимость**. Хотя переносимость программ не была основной целью языка *С*, все таки оказалось одним из его достоинств. Когда программа должна работать на компьютерах от ПК до суперкомпьютеров, она часто пишется на *С*. Одной из причин переносимости программ на языке *С* является то, что благодаря ранней связи *С* с *UNIX* и более поздним стандартам *ANSI/ISO* язык не распался на несовместимые диалекты. Другая причина заключается в том, что компиляторы языка *С* малы и легко пишутся, что помогло сделать их широко доступными. Наконец, сам язык *С* обладает свойствами, поддерживающими переносимость (хотя ничто не мешает програмистам писать непереносимые программы.
- **Мощность**. Большая коллекция типов данных и операторов языка *C* делает его мощным языком. На языке *С* часто можно добиться многого, используя всего несколько строк кода.
- Гибкость. Хотя язык *C* изначально был разработан для системного программирования, он не имеет ограничений, ограничивающих его только этой областью. В настоящее время язык *C* используется в приложениях всех видов, от встроенных систем до коммерческой обработки данных. Более того, *С* накладывает очень мало ограничений на использование своих возможностей; операции, которые были бы незаконными в других языках, часто разрешены в *С.* Например, язык *С* позволяет добавлять символ к целому значению (или, что то же самое, к числу с плавающей точкой). Такая гибкость может облегчить программирование, хотя и может позволить проскользнуть некоторым ошибкам.
- **Стандартная библиотека**. Одним из достоинств языка *С* является его стандартная библиотека, которая содержит сотни функций для ввода/вывода, работы со строками, распределения памяти и других полезных операций.
- **Интеграция с UNIX**. *C* особенно мощно сочетается с *UNIX*
(включая популярный вариант, известный как *Linux*). Фактически, некоторые инструменты *UNIX* предполагают, что пользователь знает *C*.

## Слабые стороны

Слабые стороны языка *С* проистекают из того же источника, что и многие его сильные стороны: близость языка *С* к машине. Вот несколько наиболее известных проблем языка *С*:

- **Программы на языке С могут быть подвержены ошибкам**. Гибкость языка *С* делает его языком, склонным к ошибкам. Ошибки программирования, которые были бы обнаружены во многих других языках, не могут быть обнаружены компилятором языка *С*. В этом отношении *С* очень похож на язык ассемблера, где большинство ошибок не обнаруживается до тех пор, пока программа не будет выполнена. Что еще хуже, язык *С* содержит ряд подводных камней для неопытных. В последующих главах мы увидим, как лишняя точка с запятой может создать бесконечный цикл или пропущенный символ `&` может привести к аварийному завершению программы.
- **Программы на языке С могут быть сложны для понимания**. Хотя язык *С* является небольшим языком по большинству показателей, он имеет ряд особенностей, которые встречаются не во всех языках программирования (и, следовательно, часто понимаются неправильно). Эти возможности можно комбинировать различными способами, многие из которых - хотя и очевидны для автора программы - могут быть трудны для понимания другими. Другой проблемой является краткость программ на языке *С*. *С* был разработан в то время, когда интерактивное общение с компьютером было в лучшем случае утомительным. В результате, язык *С* был специально сделан кратким, чтобы минимизировать время, необходимое для ввода и редактирования программ. Гибкость языка *С* также может быть негативным фактором; программисты, которые слишком умны для своего собственного блага, могут сделать программы почти непостижимыми.
- **Программы на языке С могут быть сложными для модификации**. Большие программы, написанные на языке *С*, могут быть трудноизменяемыми, поскольку они не были разработаны с учетом необходимости обслуживания. Современные языки программирования обычно предоставляют такие возможности, как классы и пакеты, которые поддерживают разделение большой программы на более управляемые части. *С*, к сожалению, не имеет таких возможностей.

### Обфусцированный C

Даже самые ярые поклонники языка *С* признают, что код на *С* бывает трудно читать. Ежегодный международный конкурс обфусцированного кода на *С* фактически поощряет участников писать самые запутанные программы на *С*. Победители конкурса действительно сбивают с толку, как показывает "*Лучшая маленькая программа*" 1990 года:

![B89B5200-3D42-4FDC-88E2-BBE97FD0D589.jpeg](e497702bed94489fb87433e88c695efa/B89B5200-3D42-4FDC-88E2-BBE97FD0D589.jpeg)

Эта программа, написанная Дороном Осовлански и Барухом Ниссенбаумом, печатает все решения проблемы восьми ферзей (проблема размещения восьми ферзей на шахматной доске таким образом, чтобы ни один ферзь не атаковал другого ферзя). Фактически, это работает для любого числа ферзей от четырех до 99. Больше программ-победителей можно найти на сайте конкурса [www.ioccc.org](http://www.ioccc.org/).

## Эффективное использование C

Эффективное использование *C* требует использования сильных сторон *C*, избегая при этом его слабых сторон. Вот несколько предложений:

- **Узнайте, как избежать "подводных камней".** Подсказки о том, как избежать подводных камней, разбросаны по всей книге - просто найдите соответствующий символ. Более подробный список подводных камней,
см. книгу Эндрю Кенига "*C Traps and Pitfalls*" (Reading, Mass.: Addison- Wesley, 1989). Современные компиляторы обнаруживают распространенные подводные камни и выдают предупреждения, но
ни один компилятор не обнаружит их все.
- **Используйте программные инструменты, чтобы сделать программы более надежными**. Программисты на языке *С* являются профессиональными создателями (и пользователями) инструментов. Один из самых известных инструментов языка *С* называется `lint`, который традиционно поставляется с *UNIX*, может подвергнуть программу более тщательному анализу ошибок, чем большинство компиляторов языка *С*. Если `lint` (или аналогичная программа) доступна, то лучше использовать ее. Еще один полезный инструмент - отладчик. Из-за особенностей языка *С* многие ошибки не могут быть обнаружены компилятором *С*; вместо этого они проявляются в виде ошибок во время выполнения или неправильного вывода. Поэтому использование хорошего отладчика практически обязательно для программистов на языке *С*.
- **Воспользуйтесь существующими библиотеками кода**. Одним из преимуществ использования языка *C* является то, что многие другие люди также используют его, и есть вероятность, что они написали код, который вы можете использовать в своих программах. Код на языке *С* часто объединяется в библиотеки (коллекции функций); приобретение подходящей библиотеки - хороший способ уменьшить количество ошибок и сэкономить значительные усилия при программировании. Библиотеки для общих задач, включая разработку пользовательского интерфейса, графики, коммуникаций, управления базами данных и сетей, легко доступны. Некоторые библиотеки являются общественным достоянием, некоторые - с открытым исходным кодом, а некоторые продаются на коммерческой основе.
- **Примите разумный набор соглашений о кодировании**. Соглашение о кодировании - это правило стиля, которое программист решил принять, даже если оно не соблюдается языком. Хорошо подобранные соглашения помогают сделать программы более единообразными, легче читать и легче модифицировать. Соглашения важны при использовании любого языка программирования, но особенно при использовании языка *C*. Как уже отмечалось выше, гибкость языка *C* позволяет программистам писать код, который практически не читается. Примеры программирования в этой книге следуют одному набору, но существуют и другие, не менее правильные, используемые конвенции. (Мы будем обсуждать некоторые альтернативы время от времени.) Какой набор вы используете, менее важно, чем принять некоторые соглашения и придерживаться их.
- **Избегайте "трюков" и слишком сложного кода**. *С* поощряет программистские уловки. Обычно существует несколько способов выполнения задачи на языке *С*; программисты часто испытывают искушение выбрать наиболее лаконичный метод. Не увлекайтесь: самое короткое решение часто оказывается самым сложным для понимания. В этой книге я проиллюстрирую стиль, который достаточно краток, но при этом понятен.
- **Придерживайтесь стандарта**. Большинство компиляторов языка *С* предоставляют возможности языка и библиотечные функции, которые не входят в стандарты *C89* или *C99*. Для переносимости лучше избегать использования нестандартных функций и библиотек, если они не являются абсолютно необходимыми.

# Q & A

- **Q: Что это за раздел "Вопросы и ответы"?**
- A: Рад, что вы спросили. Раздел "Вопросы и ответы", который появляется в конце каждой главы, служит нескольким целям. Основная цель "вопросов и ответов" - ответить на вопросы, которые часто задают студенты, изучающие язык *С*. Читатели могут принять участие в диалоге (более или менее) с автором, точно так же, как если бы они присутствовали на одном из моих занятий по языку *С*. Другая цель вопросов и ответов - предоставить дополнительную информацию по темам, рассмотренным в главе. Читатели этой книги, скорее всего, будут иметь очень разный опыт. Некоторые из них имеют опыт работы с другими языками программирования, в то время как другие учатся программировать впервые. Читателям с опытом работы с различными языками может быть достаточно краткого объяснения и пары примеров, но читателям с меньшим опытом может понадобиться больше. Итог: Если вы считаете, что тема освещена неполно, обратитесь к Q&A за более подробной информацией. Иногда в вопросах и ответах обсуждаются общие различия между компиляторами языка *С*. Например, мы расскажем о некоторых часто используемых (но нестандартных) функциях, которые предоставляются конкретными компиляторами.
- **Q: Что делает `lint`? [p. 6]**
- A: `lint` проверяет программу на *С* на множество потенциальных ошибок, включая, но не ограничиваясь, подозрительными комбинациями типов, неиспользуемыми переменными, недоступным кодом и непортируемым кодом. Он выдает список диагностических сообщений, которые программист должен затем обработать. Преимущество использования `lint` заключается в том, что он может обнаружить ошибки, пропущенные компилятором. С другой стороны, вы должны помнить, что нужно использовать `lint`; слишком легко забыть об этом. Хуже того, `lint` может выдавать сотни сообщений, из которых только часть относится к реальным ошибкам.
- **Q: Как `lint` получил свое название?**
- А: В отличие от названий многих других инструментов UNIX, `lint` не является акронимом; он получил свое название благодаря тому, как он собирает куски "шерсти" из программы.
- **Q: Как получить копию `lint`?**
- `lint` - это стандартная утилита UNIX; если вы используете другую операционную систему, то, скорее всего, у вас нет `lint`. К счастью, версии `lint` доступны от сторонних разработчиков. Усовершенствованная версия `lint`, известная как `splint` (*Secure Programming Lint*) включена во многие дистрибутивы Linux и может быть бесплатно загружена с сайта [www.splint.org](http://www.splint.org/).
- **Q: Есть ли способ заставить компилятор выполнять более тщательную проверку ошибок, не прибегая к использованию `lint`?**
- A: Да. Большинство компиляторов выполняют более тщательную проверку программы, если их попросить об этом. В `gcc` > версии 2.1 помимо проверок на ошибки (неоспоримые нарушения правил языка *С*), большинство компиляторов также выдают предупреждающие сообщения, указывающие на потенциальные проблемные места. Некоторые компиляторы имеют более одного "уровня предупреждения"; выбор более высокого уровня заставляет компилятор проверять больше проблем, чем выбор более низкого уровня. Если ваш компилятор
поддерживает уровни предупреждений, то лучше выбрать самый высокий уровень, чтобы компилятор выполнил самую тщательную проверку, на которую он способен. Опции проверки ошибок для компилятора `gcc`, который распространяется вместе с *Linux*, рассматриваются в разделе "Вопросы и ответы" в конце главы 2.
- **Q: Я заинтересован в том, чтобы сделать свою программу как можно более надежной. Существуют ли другие инструменты, кроме лингвистических и отладочных программ?**
- A: Да. Другие распространенные инструменты включают "средства проверки границ" и "средства поиска утечек". Язык *C* не требует проверки подзаписей массивов; программа проверки границ добавляет эту возможность. Поиск утечек помогает обнаружить "утечки памяти": блоки памяти, которые динамически выделяются, но никогда не деаллоцируются.
